% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv.R
\name{find_hcv}
\alias{find_hcv}
\title{Find optimal bandwidth using cross-validation}
\usage{
find_hcv(data, estimator, hrange = c(0, 1), num_bws = 100, plot = T, ...)
}
\arguments{
\item{data}{the data used to fit the estimator, a dataframe with columns \code{x} and \code{y}}

\item{estimator}{the estimator (\code{nw}, \code{local_average}, or another function with the same input and return types)}

\item{hrange}{a vector of length 2 specifying the range of \eqn{h}-values to try}

\item{num_bws}{number of different h-values to try in the range (default 100)}

\item{plot}{if set to \code{TRUE}, produces a plot of the CV function. Useful for checking that \code{hrange} is appropriate}

\item{...}{additional arguments to pass to the estimator (e.g. \code{kernel}, \code{empty_nhood})}
}
\value{
A list with 4 components:
\item{hcv}{the identified optimal bandwidth}
\item{mincv}{the minimal value of \eqn{CV(h)}}
\item{h}{the vector of bandwidths that have been tried}
\item{cvs}{the values of \eqn{CV(h)} for the trial bandwidths}
}
\description{
The function finds a data-driven optimal bandwidth using cross-validation.
The output is an approximation to \eqn{\hat{h}_{CV}}, which is the minimum of the function
\deqn{ CV(h) = \frac{1}{n}\sum_{i=1}^{n} (Y_i-\hat{m}^{(-i)}_h(x_i))^2 }
where \eqn{\hat{m}^{(-i)}_h} denotes the leave-one-out estimator.
}
\details{
The function is minimized approximately via a grid search.
The user specifies an interval over which to search for \eqn{h}.
The function then constructs a sequence of evenly-spaced trial bandwidths in that interval, of length \code{num_bws}, and computes \eqn{CV(h)} for each.
The best of these trial bandwidths is reported.

By default, the function also produces a plot of the function \eqn{CV(h)}. This enables the user to check that a suitable interval has been specified.
The interval should be wide enough that it is clear that the identified point is a minimum. However, if it is too wide then the discretization error from the grid search may be substantial.
}
\examples{
  # simulate and plot some data
  m <- function(x) (x^2+1)*sin(2*pi*x*((1-x) + 4*x))
  x <- sort(runif(100))
  y <- m(x) + rnorm(length(x), sd=0.1)
  simdata <- data.frame(x=x,y=y)

  find_hcv(simdata, nw, c(0,0.4))
}

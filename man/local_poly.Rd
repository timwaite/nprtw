% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/local_poly.R
\name{local_poly}
\alias{local_poly}
\title{Local polynomial estimation}
\usage{
local_poly(
  data,
  h,
  t = NULL,
  kernel = biweight,
  degree = 1,
  deriv = 0,
  empty_nhood = NaN
)
}
\arguments{
\item{data}{the data used to fit the estimator. Must be a data frame with columns \code{x} and \code{y}, where \code{x} contains the design points \eqn{x_1,\ldots,x_n}
and \code{y} contains the response values \eqn{Y_1,\ldots,Y_n}}

\item{h}{a scalar giving the user-specified bandwidth (N.B. the cross-validation bandwidth can be computed using \code{find_hcv})}

\item{t}{(optional) a vector of points at which the estimator is evaluated. If unspecified, a sequence of 200 points is created that spans the range of the x-values in the data.}

\item{kernel}{a kernel function. The package supplies \code{uniform}, \code{gauss}, \code{epanechnikov} and \code{biweight} (the default).
If the support of the kernel is bounded, ensure it is scaled to [-1,1] to ensure correct plotting of any discontinuities.}

\item{degree}{the degree \eqn{p} of local polynomial to use. Defaults to \eqn{p=1} for local linear estimation.}

\item{deriv}{if set to a positive integer, the function will estimate the \eqn{r}th derivative of the regression function, \eqn{m^{(r)}(x)}. Defauls to zero, so that \eqn{m(x)} is estimated.}

\item{empty_nhood}{a scalar specfying a custom value to be returned at locations where the estimator is undefined (as occurs when there are no nearby data points to average).
Default is \code{NaN}.}
}
\value{

}
\description{
Estimate a regression function (or its derivative) using local polynomial estimation, essentially estimating a local Taylor series using locally weighted least squares.
The function requires the user to specify a bandwidth, \eqn{h}.
}
\examples{
  #  simulate and plot some data
  m <- function(x) (x^2+1)*sin(2*pi*x*((1-x) + 4*x))
  x <- sort(runif(100))
  y <- m(x) + rnorm(length(x), sd=0.1)
  simdata <- data.frame(x=x,y=y)
  plot(simdata)

  # calculate the estimator at x=0.1, with bandwidth 0.02
  local_poly(simdata,h=0.02,t=0.1)

  # a specialised print method has been provided to make life easier
  # however, we can still access the underlying numbers e.g.

  fit <- local_poly(simdata,h=0.02,t=0.1)
  fit$mhat
  print(fit) # the same output as before

  # plot the estimator with bandwidth 0.02 using default biweight kernel
  plot(local_poly(simdata,h=0.02))

   # add a line for the estimator with bandwidth 0.4
  lines(local_poly(simdata,h=0.4), col=2)

  # add a line for the estimator using Gaussian kernel
  lines(local_poly(simdata,h=0.02,kernel=gauss), col=4)
}
